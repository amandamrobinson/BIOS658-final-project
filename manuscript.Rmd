---
title: "Method Comparison: LME vs. EdgeR for Crossover Design"
subtitle: "BIOS658 Final Project"
author: "Amanda Robinson"
date: "December 1, 2025"
bibliography: reference.bib
csl: vancouver.csl
output:
  html_document:
    code_folding: show
    toc: true
    toc_float:
      collapsed: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, error = FALSE, 
                      message = FALSE)
```

# Introduction

Repeated measurements allow us to explore changes of phenomena over time while also accounting for variation inherent to an individual. Linear mixed effects models are often used to parse apart the effect of interest from person to person variation. Common methods for differential expression analysis like `edgeR` [@robinson2010edger] are not able to support the inclusion of random effects. The goal of this study is to see if differential expression analysis with `edgeR` is able to identify trends in expression over time without accounting for within subject variation. 

To do so, we leverage publicly available data from a crossover study of individuals with major depressive disorder (MDD) of different phenotypes (hyper- vs hypophagia) [@dan2024divergent]. Blood samples were collected from subjects over two visits both before (T0) and after (T105) undergoing either a stress test or a control. RNA-seq was used to measure gene expression.

# Methods

We obtained Bulk RNA-seq data through GEO Accession GSE231347. Data were restricted to T105 and subjects with measurements at both the stress test and control visits. We filtered out genes with low expression using `filterByExpr` from `edgeR` [@chen2016reads]. We then normalized the data using trimmed mean of M-values (TMM) method via the `edgeR` `calcNormFactors` function."

There were no known batch effects for this data. However the nature of the experimental design required subjects to be measured on different days, so we elected to correct for any latent batch effects using surrogate variable analysis (SVA) [@leek2007capturing]. The number of SVs estimated by Leek's method was relatively high compared to our sample size, so we instead used the less conservative Buja and Eyuboglu estimate.    

We used `edgeR` with quasi-likelihood (QL) estimation for differential expression analysis. Expression was modeled with fixed effects for MDD phenotype, visit condition (stress vs no stress), an interaction between the two, and SVs. While clinical measurements were included in the original analysis, they were not available on GEO. We could not include them in this analysis. We were not able to account for repeated measurements within a subject as the `edgeR` QL framework does not support mixed effects model. Differential expression was based on the QL F-test applied to the MDD phenotype/visit condition interaction term.

We examined functional enrichment via over-representation (ORA) and gene set enrichment analysis (GSEA) with the `clusterProfiler` package [@yu2012clusterprofiler] using both the Kyoto Encyclopedia of Genes and Genomes and Gene Ontology databases. Genes with $log_2 FC > 1$ and $p < 0.05$ identified during differential expression analysis were included in ORA. A list of genes ordered by $log_2FC$ was used for GSEA. We defined enriched pathways as those with either $FDR < 0.05$ in GSEA or $q < 0.2$ in ORA.   

Analyses were completed in `r R.version.string`.

# Results

```{r data}
library(tidyverse)
library(GEOquery)
library(pheatmap)
library(limma)
library(sva)
library(edgeR)
library(ggrepel)
library(clusterProfiler)
library(org.Hs.eg.db)
library(AnnotationDbi)

options(scipen = 999)
set.seed(38451)

#To track figure and table numbers
fig.num <- 0
tab.num <- 0

#Data obtained from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE231347
#read_csv() automatically unzips .gz files
gene_counts <- read_csv("GSE231347_counts.csv.gz")

gse <- getGEO("GSE231347", GSEMatrix = TRUE)
#Extract the expression set
gse_data <- gse[[1]]

# Create data frame from GEO phenoData.
phenotype <- pData(gse_data) %>%
  dplyr::rename(condition = `condition:ch1`, 
                mdd_phenotype = `mdd phenotype:ch1`, 
                timepoint = `time point:ch1`) %>%
  #The sample IDs are a concatenation of subject id, mdd_phenotype, and visit
  #I need to extract the subject ID
  mutate(id = str_extract(title, "G[0-9]+"), 
         mdd_phenotype = fct_rev(factor(mdd_phenotype))) %>%
  #Like the original paper, we will restrict the model to observations after the
  #subject completed the stress test or control waiting time
  filter(timepoint == "T105") %>%
  #There were some subjects with only one record. To identify them I looked at 
  #each subject
  group_by(id) %>%
  #Counted how many records they had
  add_count() %>%
  #And filtered the data to only those subjects that had more than one 
  #observation
  filter(n > 1) %>%
  #I only keep the information needed for my analysis
  dplyr::select(title, id, mdd_phenotype, condition) %>%
  ungroup()

#Restrict gene_counts to only those observations retained in phenotype after 
#filtering
gene_counts <- gene_counts[, c("gene", phenotype$title)]

n_summ <-phenotype %>%
  distinct(id, .keep_all = TRUE) %>%
  count(mdd_phenotype)
```


We identified `r nrow(n_summ)` subjects meeting the inclusion criteria, of which `r n_summ$n[1]` were diagnosed with hyperphagia and `r n_summ$n[2]` were diagnosed with hypophagia.

## Quality Assessment

```{r qa-library-size}
library_size <- gene_counts %>%
  dplyr::select(-gene) %>%
  #Count the number of reads per sample
  colSums()

#Summary statistics for text
lib_summ <- round(quantile(library_size, c(0.25, 0.5, 0.75))/1000000, 1)
lib_text <- paste0(lib_summ[2], "[IQR: ", lib_summ[1], ", ", lib_summ[3], "]")
```

**Figure `r fig.num + 1`** shows the distribution of library size in millions. Median library size was `r lib_text` million. 

```{r qa-library-size-fig}
fig.num <- fig.num + 1

ggplot() + 
  geom_boxplot(aes(y = library_size/1000000)) +
  ylab("Library Size (Millions)") +
  ggtitle(paste0("Figure ", fig.num, ": Distribution of Library Size")) +
  theme_bw()
```

```{r qa-count-distribution}
#I want to make gene_counts long for ease of summary and plotting
gene_counts_long <- gene_counts %>%
  pivot_longer(-gene, names_to = "sample", values_to = "count") %>%
  #I will display log2 expression due to skewed count distributions for some 
  #samples
  mutate(log2_count = log2(count + 1))

#Summary statistics for text
log2_q3_range <- gene_counts_long %>%
  #For each sample
  group_by(sample) %>%
  #Find Q3
  summarise(q3 = quantile(log2_count, 0.75)) %>%
  #The find the min and max Q3
  summarise(min = round(min(q3), 1), 
            max = round(max(q3), 1))
```

**Figure `r fig.num + 1`** shows the distribution of $log_2$ gene count by sample. Most genes were not expressed across all samples. The minimum 75th percentile observed was `r log2_q3_range$min[1]` while the maximum was `r log2_q3_range$max[1]`.

```{r qa-count-distribution-fig}
fig.num <- fig.num + 1

gene_counts_long %>%
  ggplot() + 
  geom_boxplot(aes(y = log2_count, x = sample)) +
  xlab("Sample") +
  ylab("Log2 Count + 1") +
  ggtitle(paste0("Figure ", fig.num, ": Distribution of Gene Count by Sample")) +
  theme_bw() +
  theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank())
```

```{r housekeeping}
#Retain the list of genes in the data
genes <- gene_counts$gene

#I kept gene_counts as a data frame up to this point for visualization and 
#summary, but I will need it to be a matrix for the rest of the analysis
gene_counts <- gene_counts %>%
  dplyr::select(-gene) %>%
  as.matrix()

#Assign gene names as the rownames of gene_counts
rownames(gene_counts) <- genes

#Checks to make sure the columns of gene_counts align with the rows of phenotype
# phenotype$title == colnames(gene_counts)
```

**Figure `r fig.num + 1`** shows the Pearson correlation for $logCPM$ between samples. Observations from the same subject tended to be clustered together.

```{r qa-sample-correlation}
fig.num <- fig.num + 1

#Pearson correlation assumes a normal distribution, so I normalize gene_counts 
#to counts per million and take the log since counts are not normal
logCPM <- cpm(gene_counts, log = TRUE)

sample_cor <- cor(logCPM, method = "pearson")

#Data for figure annotation
annotation_data <- data.frame(Group = phenotype$mdd_phenotype,
                              Visit = phenotype$condition, 
                              id = phenotype$id,
                              row.names = colnames(sample_cor))

pheatmap(sample_cor,
         annotation_col = annotation_data,
         show_rownames = FALSE,
         show_colnames = FALSE,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         main = paste0("Figure ", fig.num, 
                       ": Sample Correlation of LogCPM Gene Count"))
```

## Preprocessing

```{r preprocessing}
#This is equivalent to the mdd_phenotype + condition + mdd_phenotype * condition
#model that I end up fitting as part of the differential expression analysis. 
#It allows me to have one group variable for the purposes of normalization and
#filtering.
TypeCondition <- interaction(phenotype$mdd_phenotype, phenotype$condition)

#We will also need the design matrix
design <- model.matrix(~ TypeCondition)

#A. Format data as a DGEList
#We need to create a DGEList object to feed into the edgeR functions. 
y <- DGEList(counts = gene_counts, genes = rownames(gene_counts), 
             group = TypeCondition)

#B. Filter
#The documentation recommends filtering out genes with low or zero counts across
#all samples using this code. It also says you can include variables of 
#scientific interest (TypeCondition in our case) in this step, which I choose to
#do here.
keep <- filterByExpr(y, group = TypeCondition)
#We need to recalculate library size since we removed some genes
y <- y[keep, , keep.lib.sizes = FALSE]

#C. Normalization
#A few highly expressed genes may account for most of the library size, 
#resulting in under-sampling of genes with lower expression. We can address this
#issue through normalization. 
y <- normLibSizes(y)
```

## Batch Effect Correction

```{r sva}
#Null model
mod0 <- model.matrix(~1, data = phenotype)  
#Estimate number of surrogate variables. Leek returned a large number of SVs 
#relative to my sample size, so I used the less conservative BE method.
# n.sv <- num.sv(y$counts, design, method = "leek")
n.sv <- num.sv(y$counts, design, method = "be")

# Run svaseq to estimate surrogate variables
svseq <- svaseq(dat = y$counts, mod = design, mod0 = mod0, n.sv = n.sv)

# Remove surrogate variable effects using limma::removeBatchEffect (treat sv's 
#as covariates)
sv_mat <- svseq$sv
#logCPM of SV corrected counts
sva_corrected <- removeBatchEffect(cpm(y, log = TRUE), covariates = sv_mat)

#Give clearer names to the columns of sv_mat
colnames(sv_mat) <- paste0("SV", 1:ncol(sv_mat))

#Add sv_mat to phenotype
phenotype <- cbind(phenotype, sv_mat) 
```

**Table `r tab.num + 1`** summarizes the results of principal components analysis (PCA) before and after batch correction with SVA. The first two PCs accounted for 26% of the variance in $log_2CPM$ before batch correction and 17% after batch correction.

```{r pca-tab}
tab.num <- tab.num + 1
pca_tab <- tab.num


logCPM <- cpm(y, log = TRUE)

#PCA assumes normally distributed data, so we use logCMP
pca <- prcomp(t(logCPM), scale. = TRUE)
#And SV corrected logCPM
pca_sva <- prcomp(t(sva_corrected), scale. = TRUE)

#Combine summary measures into a single table for display
rbind(summary(pca)$importance, 
      summary(pca_sva)$importance) %>%
  data.frame() %>%
  rownames_to_column(var = "Measure") %>%
  mutate(SVA = c(rep("No SVA", 3), rep("SVA", 3)), 
         Measure = str_remove(str_replace_all(Measure, "[.]", " "), 
                              "[0-9]+"), 
         across(is.numeric, round, 4)) %>%
  dplyr::select(SVA, Measure, contains("PC")) %>%
  DT::datatable(rownames = FALSE, 
                caption = paste0("Table ", tab.num, 
                                 ": PCA Variance Explained Before and After SVA Correction"),
                # Display only 10 rows per page
                options = list(pageLength = 10,
                # Optional: adds vertical scrolling if needed
                scrollY = "400px", 
                # Removes the search bar and only keeps table/pagination
                dom = 'tp', 
                # Enables pagination
                paging = TRUE, 
                scrollX = TRUE))
```

**Figure `r fig.num + 1`** shows the first two PCs by MDD phenotype, visit condition, and batch effect correction. There is some separation between MDD phenotypes after the stress test both before and after correcting for SVs. There is no such separation observed for the control measurements.

```{r pca-fig}
fig.num <- fig.num + 1

phenotype %>%
  dplyr::select(id, mdd_phenotype, condition) %>%
  mutate(pc1_nosva = pca$x[, 1], 
         pc2_nosva = pca$x[, 2], 
         pc1_sva = pca_sva$x[, 1], 
         pc2_sva = pca_sva$x[, 2]) %>%
  #I want one record per sample, pc, and presence of batch effect correction
  pivot_longer(c(-id, -mdd_phenotype, -condition), names_to = "method_pc", 
               values_to = "value") %>%
  #Divide method_pc into two columns
  separate_wider_delim(cols = method_pc, delim = "_", 
                       names = c("pc", "method")) %>%
  #Clean up labels
  mutate(method = factor(method, levels = c("nosva", "sva"), 
                         labels = c("No SVA", "SVA")), 
         condition = factor(condition, levels = c("S", "NS"), 
                            labels = c("Stress Test", "Control"))) %>%
  #Reformat data so there is one record per sample and batch effect correction
  pivot_wider(names_from = pc, values_from = value) %>%
  ggplot() + 
  geom_point(aes(x = pc1, y = pc2, color = mdd_phenotype)) +
  labs(title = paste0("Figure ", fig.num, 
                      ": Principle Components by MDD Phenotype, Batch Effect 
                      Correction, and Condition"), 
       x = "PC1", 
       y = "PC2", 
       color = "Phagia") +
  theme_bw() +
  facet_grid(condition~method) +
  theme(legend.position = "bottom")
```

**Figure `r fig.num + 1`** shows hierarchical clustering of the top 10 most variable genes prior to batch effect correction. Observations from the same subject are clustered together, and subjects were further clustered by MDD phenotype.

```{r hierarchical-clustering-1}
fig.num <- fig.num + 1

#Find the IQR for each gene. This is a more robust measure than SD
gene_iqr <- apply(logCPM, 1, IQR)
names(gene_iqr) <- y$genes$genes

#Determine the cutoff for the top 10% most variable genes
iqr_cutoff <- quantile(gene_iqr, 0.90)

#Select the genes that exceed the cutoff
#This set of genes will be used for BOTH the Before and After SVA plots.
top_10_percent_genes <- names(gene_iqr[gene_iqr >= iqr_cutoff])

pheatmap(
  #Uses uncorrected data
  logCPM[top_10_percent_genes, ], 
  show_rownames = FALSE,
  show_colnames = FALSE,
  annotation = annotation_data, 
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  main = paste0("Figure ", fig.num, 
                ": Clustering of Top 10% Genes Before SVA Correction"),
  fontsize = 8
)
```

**Figure `r fig.num + 1`** shows hierarchical clustering of the top 10 most variable genes after batch effect correction. Observations remain clustered around subject and MDD phenotype, though less strongly.

```{r hierarchical-clustering-2}
fig.num <- fig.num + 1

pheatmap(
  #Uses SV corrected data
  sva_corrected[top_10_percent_genes, ],
  show_rownames = FALSE,
  show_colnames = FALSE,
  annotation = annotation_data, 
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  main = paste0("Figure ", fig.num, 
                ": Clustering of Top 10% Genes After SVA Correction"),
  fontsize = 8
)
```

## Differential Expression Analysis

```{r differential-expression}
#Update design matrix to include SVs
design_final <- model.matrix(as.formula(paste0("~ mdd_phenotype + condition + 
                                               mdd_phenotype * condition +", 
                                               paste0("SV", 1:ncol(sv_mat), 
                                                      collapse = " + "))), 
                             data = phenotype)

#D. Estimating Dispersion
#The authors recommend calculating the overall and tag-wise dispersion
y <- estimateDisp(y, design = design_final)

#E. Fit and Test Model
#I am using the quasi-likelihood pipeline
#"The QL F-tests provide more rigorous error rate control compared to methods 
#that do not fully account for the uncertainty in quasi-dispersion estimation."
fit_edgeR <- glmQLFit(y, design_final)

#I want to test the interaction to see if there is a significant difference in 
#expression across mdd_phenotype after the stress test
qlf_interaction <- glmQLFTest(fit_edgeR, coef = "mdd_phenotypeHyper:conditionS")

results <- topTags(qlf_interaction, 
                   #We want to keep any gene that meets our criteria
                   n = Inf, 
                   #We will use p-values to determine which genes to keep
                   sort.by = "PValue", 
                   #And us BH adjustment to control FDR
                   adjust.method = "BH")

#results is ordered by ascending p-value
top10 <- results$table[1:10, ]

#Data for volcano plot
fc_threshold <- 1  # log2FC threshold
pval_threshold <- 0.05

gene_symbol_map <- AnnotationDbi::select(org.Hs.eg.db,
                                        keys = rownames(top10),
                                        columns = "SYMBOL",
                                        keytype = "ENSEMBL") %>%
  # 2. Handle 1-to-many mappings by keeping the first unique ENSEMBL ID
  dplyr::distinct(ENSEMBL, .keep_all = TRUE)

ensembl_to_symbol <- setNames(gene_symbol_map$SYMBOL, gene_symbol_map$ENSEMBL)

top10_labels <- top10 %>%
  mutate(Gene_Symbol = replace_na(ensembl_to_symbol[rownames(.)], 
                                  "Unassigned"), 
         Display_Label = ifelse(Gene_Symbol == "Unassigned", genes, 
                                Gene_Symbol)) %>%
  dplyr::select(genes, Gene_Symbol, Display_Label)

volcano_data <- results$table %>%
  left_join(top10_labels) %>%
  mutate(neg_log10_p = -log10(PValue),
         status = case_when(PValue < pval_threshold & logFC >= 1 ~ 
                              "Upregulated",
                            PValue < pval_threshold & logFC <= -1 ~ 
                              "Downregulated",
                            TRUE ~ "Not Significant"), 
         label = ifelse(genes %in% top10$genes, Display_Label, "")) 

volcano_text <- volcano_data %>%
  filter(status != "Not Significant") %>%
  count(status)
```

**Figure `r fig.num + 1`** summarizes the statistical significance and magnitude of the MDD phenotype visit/interaction term. The volcano plot is generally symmetric. There were `r sum(volcano_text$n)` differentially expressed genes, of which `r volcano_text[2, 2]` were upregulated and `r volcano_text[1, 2]` were downregulated.

```{r volcano plot}
fig.num <- fig.num + 1

volcano_data %>% 
  ggplot() + 
  geom_point(aes(x = logFC, y = neg_log10_p, color = fct_rev(status))) +
  scale_color_manual(values = c("Upregulated" = "red",
                                "Downregulated" = "blue",
                                "Not Significant" = "grey50")) +
  # Add threshold lines
  geom_vline(xintercept = c(-fc_threshold, fc_threshold), 
             linetype = "dashed", color = "black", linewidth = 0.5) +
  geom_hline(yintercept = -log10(pval_threshold), 
             linetype = "dashed", color = "black", linewidth = 0.5) +
  geom_text_repel(aes(x = logFC, y = neg_log10_p, label = label),
                  size = 3, max.overlaps = 15) +
  labs(title = paste0("Figure ", fig.num, 
                      ": Volcano Plot with Top Gene Labels"), 
       subtitle = paste0("Thresholds: |Log2FC| \u2265 ", fc_threshold, 
                         " and P-value \u2264 ", pval_threshold), 
       x = "LogFC", 
       y = "-Log10 p-value", 
       color = "") +
  theme_bw()
```

**Table `r tab.num + 1`** summarizes the top 10 most differentially expressed genes, none of which met the FDR < 0.05 threshold for statistical significance.

```{r top10-tab}
tab.num <- tab.num + 1

top10 %>%
  left_join(top10_labels) %>%
  dplyr::select(genes, Gene_Symbol, logFC, PValue, FDR) %>%
  mutate(across(is.numeric, round, 4)) %>%
  dplyr::rename(Gene = genes, "Gene Symbol" = Gene_Symbol) %>%
  DT::datatable(rownames = FALSE, 
                caption = paste0("Table ", tab.num, 
                                 ": Summary of Top 10 Differentially Expressed Genes"),
                # Display only 10 rows per page
                options = list(pageLength = 10,
                # Optional: adds vertical scrolling if needed
                scrollY = "400px", 
                # Removes the search bar and only keeps table/pagination
                dom = 'tp', 
                # Enables pagination
                paging = TRUE, 
                scrollX = TRUE))
```

**Figure `r fig.num + 1`** shows the distribution of SVA corrected $log_2CPM$ by MDD phenotype, condition, and gene for the top 10 most differentially expressed genes. Most genes showed a slight change in expression between control and stress test visits within MDD phenotypes. Additionally, genes that tended to be upregulated during stress for subjects with hypophagia tended to be downregulated in those with hyperpagia and vice versa.

```{r boxplot}
fig.num <- fig.num + 1
box.fig <- fig.num

sva_corrected[top10$genes, ] %>%
  t() %>%
  data.frame() %>%
  rownames_to_column("title") %>%
  pivot_longer(-title, names_to = "gene", values_to = "count") %>%
  left_join(phenotype) %>%
  mutate(condition = factor(condition, levels = c("S", "NS"), 
                            labels = c("Stress Test", "Control"))) %>%
  left_join(top10_labels, by = c("gene" = "genes")) %>%
  ggplot() + 
  geom_boxplot(aes(x = mdd_phenotype, y = count, color = fct_rev(condition))) +
  labs(title = paste0("Figure ", fig.num, ": SVA Corrected Log CPM by MDD Phenotype, Condition, and Gene"), 
       x = "MDD Phenotype", 
       y = "SVA Corrected Log CPM", 
       color = "") +
  facet_wrap(~Display_Label, ncol = 5) + 
  theme_bw() +
  theme(legend.position = "bottom")
```

## Functional Enrichment Analysis

```{r functional-enrichment}
#Create a temporary data frame of LogFC values and ENSEMBL IDs
temp_df <- results$table %>%
  rownames_to_column(var = "ENSEMBL") %>%
  dplyr::select(ENSEMBL, logFC, PValue) 

#I have ENSEMBL IDs but clusterProfiler wants ENTREZ IDs
eg_mapping <- bitr(temp_df$ENSEMBL, 
                   fromType = "ENSEMBL",
                   toType = "ENTREZID", 
                   OrgDb = "org.Hs.eg.db") %>%
  #Keep only one ENTREZ ID mapped to an ENSEMBL ID. Might have many to one
  distinct(ENSEMBL, .keep_all = TRUE) 

df_final <- temp_df %>%
  #Join LogFC results with the Entrez ID mapping table
  inner_join(eg_mapping, by = "ENSEMBL") %>%
  #Group by Entrez ID
  group_by(ENTREZID) %>%
  #Keep the largest signal
  summarise(logFC = max(logFC)) %>%
  ungroup()

#Create the final sorted numeric vector of logFC for GSEA
ranked_gene_list <- df_final$logFC
names(ranked_gene_list) <- df_final$ENTREZID
ranked_gene_list <- sort(ranked_gene_list, decreasing = TRUE)

#We need to identify genes of interest for ORA
ora_degs_entrez <- temp_df %>%
  #No gene had FDR < 0.05, so I will use the same criteria I used to identify 
  #up- and down-regulated genes in the above volcano plot
  filter(PValue < pval_threshold & abs(logFC) >= fc_threshold) %>%
  inner_join(eg_mapping, by = "ENSEMBL") %>%
  distinct(ENTREZID, .keep_all = TRUE)

#GSEA Analysis

#KEGG
gsea_results_kegg <- gseKEGG(geneList = ranked_gene_list,
                             #hsa is homo sapien
                             organism = 'hsa', 
                             nPerm = 1000, 
                             pvalueCutoff = 0.05, 
                             verbose = FALSE)

#Gene Ontology
gsea_results_go <- gseGO(geneList = ranked_gene_list, 
                         OrgDb = org.Hs.eg.db, 
                         ont = "ALL",
                         keyType = "ENTREZID",
                         pvalueCutoff = 0.05, 
                         verbose = FALSE)

#ORA

#KEGG
ora_results_kegg <- enrichKEGG(gene = ora_degs_entrez$ENTREZID, 
                               organism = 'hsa', 
                               pvalueCutoff = 0.05, 
                               qvalueCutoff = 0.20)

#Gene Ontology
ora_results_go <- enrichGO(gene = ora_degs_entrez$ENTREZID, 
                           OrgDb = org.Hs.eg.db,
                           ont = "ALL",                     
                           keyType = "ENTREZID",
                           pvalueCutoff = 0.05, 
                           qvalueCutoff = 0.20)

#Combine results for table

#GSEA Results (KEGG & GO)
gsea_table_kegg <- gsea_results_kegg@result %>% 
  mutate(Method = "GSEA: KEGG")

gsea_table_go <- gsea_results_go@result %>% 
  mutate(Method = paste0("GSEA: ", 
                         case_when(ONTOLOGY == "BP" ~ "Biological Process",
                                   ONTOLOGY == "MF" ~ "Molecular Function", 
                                   ONTOLOGY == "CC" ~ "Cellular Component")))

gsea_final_table <- bind_rows(gsea_table_kegg, gsea_table_go) %>%
  filter(p.adjust < 0.05) %>%
  dplyr::select(ID, Description, setSize, pvalue, p.adjust, Method) %>%
  mutate(across(c(pvalue, p.adjust), round, 4))

#ORA Results (KEGG & GO)
ora_table_kegg <- data.frame(ora_results_kegg) %>% 
  mutate(Method = "ORA: KEGG")

ora_table_go <- data.frame(ora_results_go) %>% 
  mutate(Method = paste0("ORA: ", 
                         case_when(ONTOLOGY == "BP" ~ "Biological Process",
                                   ONTOLOGY == "MF" ~ "Molecular Function", 
                                   ONTOLOGY == "CC" ~ "Cellular Component")))

ora_final_table <- bind_rows(ora_table_kegg, ora_table_go) %>%
  filter(p.adjust < 0.2) %>%
  dplyr::select(ID, Description, Count, pvalue, p.adjust, Method) %>%
  mutate(setSize = Count,
         across(c(pvalue, p.adjust), round, 4)) %>%
  dplyr::select(ID, Description, setSize, pvalue, p.adjust, Method)

# C. Combine, Sort, and Display the Final Table
final_enrichment_results <- bind_rows(gsea_final_table, ora_final_table) %>%
  arrange(p.adjust)
```

**Table `r tab.num + 1`** summarizes the enriched pathways identified during ORA and GSEA. Several processes related to immune response were enriched.

```{r functional-enrichment-tab}
tab.num <- tab.num + 1

final_enrichment_results %>%
  dplyr::rename("Set Size" = setSize, "p-value" = pvalue, 
                "Adjusted p-value" = p.adjust) %>%
  DT::datatable(rownames = FALSE, 
                caption = paste0("Table ", tab.num, 
                                 ": Significant Functional Enrichment Results"),
                options = list(pageLength = 10, scrollX = TRUE))
```

# Discussion

Our goal for this analysis was to identify any genes with expression significantly associated with the MDD phenotype/visit condition interaction. There were `r sum(volcano_data$n)` with nominal differential expression ($p < 0.05$ and $|log_2FC| \ge 1$), though none achieved $FDR < 0.05$ after correcting for multiple testing. We identified `r nrow(final_enrichment_results)` pathways during functional enrichment analysis, most of which were associated with immune response.

With 36 observations, it is likely that our failure to identify any genes with significant differential expression is due in part to low statistical power. Additionally, variance estimates were inflated as we did not account for repeated measurements within a subject. Clinical measurements like age or sex may also account for variation in gene expression in this population, which we were unable to model due to these data being unavailable. 

These limitations are further supported by the original paper, which identified two differentially expressed genes with a linear mixed effect model adjusting for clinical factors. Specifically, CCDC196 was upregulated in hyperphagic MDD and SPATA33 in was downregulated. Our analysis found nominal differential expression of SPATA33 consistent with this divergence. **Figure `r box.fig`** also shows diverging expression across MDD phenotype under stress.

Despite these limitations, we were able to address the impact of variance due to latent batch factors using SVA. We observed a decrease in the variance explained by the first two PCs after batch effect correction (**Table `r pca_tab`**), confirming SVA was successful.

While we were not able to identify individual genes with significant differential expression, the results of the functional enrichment analysis suggest a general difference in expression of sets of genes related to immune response. Interestingly, the the functional enrichment analysis in the original paper identified pathways related to ribosomal activity.   

Even without accounting for repeated measurements, our study shows fundamentally different biological responses between MDD phenotypes under stress, a finding that aligns with the results of the original paper. These phenotypic differences are associated with immune response. 

# References
